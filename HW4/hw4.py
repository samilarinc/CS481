"""Bio_Inf_HW4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ehqldnuEPGx5Te4eh2QO5V-b-KCoDeVv
"""

import numpy as np
from argparse import ArgumentParser
from sys import argv

parser = ArgumentParser()
parser.add_argument("--ref", required=True)
parser.add_argument("--qry", required=True)
parser.add_argument("--k", required=True)
parser.add_argument("--s", required=True)
args = parser.parse_args()

ref_file_adr = args.ref
query_file_adr = args.qry
k = int(args.k)
match_score = 1
mismatch_score = -2
gap_score = -3
score_thres = int(args.s)

def read_fasta(f_adr:str) -> list:
    with open(f_adr, 'r') as f_stream:
        seqs = []
        seq = ""
        for line in f_stream:
            line_data = line.strip()
            if len(line_data) > 0:
                if line_data[0] == '>':
                    if len(seq) > 0:
                        seqs.append(seq)
                        seq = ""
                else:
                    seq += line_data
        seqs.append(seq)
    return seqs

def hash(inStr, mod = 3343):  # i tried different numbers. 3347 is totally safe to use with this reference and k = 5
    fp = 0
    for i in range(len(inStr)):
        c = (ord(inStr[i]) >> 1) & 3
        for j in range(i):
            c = (c * 4) % mod
        fp += c
        fp %= mod
    return fp

ref = read_fasta(ref_file_adr)[0]
queries = read_fasta(query_file_adr)
little_qs = [[] for _ in range(len(queries))]

for i in range(len(queries)):
    for j in range(len(queries[i])-k+1):
        little_qs[i].append(queries[i][j:j+k])

hash_q = [[] for _ in range(len(queries))]
for i in range(len(little_qs)):
    for j in little_qs[i]:
        hash_q[i].append(hash(j))

loc_q = [[[] for i in range(len(hash_q[0]))] for j in range(len(hash_q))]
for i in range(len(ref) - k):
    if i % (len(ref) // 100) == 0:
        print(f'\r{i // (len(ref)//100)}%', end = '')
    temp_hash = hash(ref[i:i+k])
    for ii in range(len(hash_q)):
        try:
            loc = hash_q[ii].index(temp_hash)
            loc_q[ii][loc].append(i)
        except ValueError:
            pass
print('\r100%', end = '')
print(f'\rSearch done on reference file for {len(loc_q)} queries')

query_in_ref = [[] for _ in range(len(queries))]

for i in range(len(loc_q)):
    print('\rQuery', i+1, 'out of', len(loc_q), end = '')
    for loc1 in range(len(loc_q[i])):
        for loc2 in loc_q[i][loc1]:
            score = k+1
            query = queries[i]
            little_q = little_qs[i][loc1]
            start = query.find(little_q) # take start pos when initialize
            last_score = k+1
            last_inc_left = loc2
            query_left = start
            query_right = start + k - 1
            last_inc_right = loc2 + k
            
            iii = 1
            while score > k and loc2 - iii >= 0 and start - iii > 0:
                if ref[loc2-iii] == query[start-iii]:
                    score += match_score
                    if score > last_score:
                        last_inc_left = loc2 - iii
                        query_left = start - iii
                        last_score = score
                else:
                    score += mismatch_score
                iii += 1
            
            iii = 1
            while score > last_score and loc2 + k + iii < len(ref) and start + k + iii < len(query):
                if ref[loc2+k+iii] == query[start+k+iii]:
                    score += match_score
                    if score > last_score:
                        last_inc_right = loc2 + k + iii
                        query_right = start + k + iii - 1
                        last_score = score
                else:
                    score += mismatch_score
                iii += 1
            if last_score-1 >= score_thres:
                query_in_ref[i].append((last_score-1, last_inc_left, last_inc_right, query_left, query_right))
print('\n\n')

for ii in range(len(query_in_ref)):
    locations = query_in_ref[iii]
    query = queries[ii]
    max_score = 0
    start_loc = 0
    for score, r_left, r_right, q_left, q_right in locations:
        table = np.zeros((len(query), len(query)))
        table[q_left, q_left] = score
        table[q_right, q_right] = score
        for i in range(1, q_left+1):
            for j in range(1, q_left+1):
                if i == j:
                    table[q_left-i, q_left-j] = max(table[q_left-i+1, q_left-j+1] + (match_score if query[q_left-i] == ref[r_left-i] else mismatch_score), 
                                                    table[q_left-i+1, q_left-j] + gap_score,
                                                    table[q_left-i, q_left-j+1] + gap_score)
                else:
                    table[q_left-i, q_left-j] = max(table[q_left-i+1, q_left-j] + gap_score,
                                                    table[q_left-i, q_left-j+1] + gap_score)
        for i in range(1, len(query)-q_right):   
            for j in range(1, len(query)-q_right):
                if i == j:
                    table[q_right+i, q_right+j] = max(table[q_right+i-1, q_right+j-1] + (match_score if query[q_right+i] == ref[r_right+i] else mismatch_score), 
                                                    table[q_right+i-1, q_right+j] + gap_score,
                                                    table[q_right+i, q_right+j-1] + gap_score)
                else:
                    table[q_right+i, q_right+j] = max(table[q_right+i-1, q_right+j] + gap_score,
                                                    table[q_right+i, q_right+j-1] + gap_score)
        maxi = table.max()
        if maxi > max_score: 
            max_score = maxi
            start_loc = r_left
    print('> %-6s: %5d'%(f'Seq{ii+1}', start_loc))

